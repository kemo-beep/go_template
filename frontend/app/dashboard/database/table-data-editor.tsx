'use client';

import { useState, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Label } from '@/components/ui/label';
import { toast } from 'sonner';
import { Pencil, Trash2, Plus, Save, X, ChevronLeft, ChevronRight } from 'lucide-react';
import { api } from '@/lib/api-client';

interface TableDataEditorProps {
    tableName: string;
}

interface ColumnInfo {
    name: string;
    type: string;
    nullable: boolean;
    default_value?: string;
    is_primary_key: boolean;
}

interface RowData {
    [key: string]: any;
}

export default function TableDataEditor({ tableName }: TableDataEditorProps) {
    const [page, setPage] = useState(1);
    const [pageSize] = useState(50);
    const [editingRow, setEditingRow] = useState<RowData | null>(null);
    const [isAddingRow, setIsAddingRow] = useState(false);
    const [newRow, setNewRow] = useState<RowData>({});
    const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
    const [rowToDelete, setRowToDelete] = useState<RowData | null>(null);

    const queryClient = useQueryClient();

    // Reset page when table changes
    useEffect(() => {
        setPage(1);
        setEditingRow(null);
        setIsAddingRow(false);
    }, [tableName]);

    // Fetch table schema
    const { data: schemaData } = useQuery({
        queryKey: ['tableSchema', tableName],
        queryFn: () => api.getTableSchema(tableName),
        enabled: !!tableName,
    });

    const columns: ColumnInfo[] = schemaData?.data?.data?.columns || schemaData?.data?.columns || [];
    const primaryKey = columns.find(col => col.is_primary_key)?.name;

    // Fetch table data
    const { data: tableData, isLoading } = useQuery({
        queryKey: ['tableData', tableName, page],
        queryFn: () => api.getTableData(tableName, page, pageSize),
        enabled: !!tableName,
    });

    const rows: RowData[] = tableData?.data?.data?.data || tableData?.data?.rows || [];
    const totalRows = tableData?.data?.data?.total || tableData?.data?.total || 0;
    const totalPages = Math.ceil(totalRows / pageSize);

    // Initialize new row with default values (excluding auto-generated columns)
    useEffect(() => {
        if (isAddingRow && columns.length > 0) {
            const initialRow: RowData = {};
            columns.forEach(col => {
                // Skip auto-generated columns (primary keys with default nextval, created_at, updated_at)
                const isAutoGenerated = col.is_primary_key ||
                    col.default_value?.includes('nextval') ||
                    ['created_at', 'updated_at', 'deleted_at'].includes(col.name.toLowerCase());

                if (isAutoGenerated) {
                    return; // Don't include in new row form
                }

                if (col.default_value && !col.default_value.includes('nextval')) {
                    initialRow[col.name] = col.default_value;
                } else if (col.nullable) {
                    initialRow[col.name] = null;
                } else {
                    initialRow[col.name] = '';
                }
            });
            setNewRow(initialRow);
        }
    }, [isAddingRow, columns]);

    // Add row mutation
    const addRowMutation = useMutation({
        mutationFn: (row: RowData) => api.insertTableRow(tableName, row),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['tableData', tableName] });
            toast.success('Row added successfully');
            setIsAddingRow(false);
            setNewRow({});
        },
        onError: (error: any) => {
            toast.error(error.response?.data?.error || 'Failed to add row');
        },
    });

    // Update row mutation
    const updateRowMutation = useMutation({
        mutationFn: ({ row, pkValue }: { row: RowData; pkValue: any }) =>
            api.updateTableRow(tableName, pkValue, row),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['tableData', tableName] });
            toast.success('Row updated successfully');
            setEditingRow(null);
        },
        onError: (error: any) => {
            toast.error(error.response?.data?.error || 'Failed to update row');
        },
    });

    // Delete row mutation
    const deleteRowMutation = useMutation({
        mutationFn: (pkValue: any) => api.deleteTableRow(tableName, pkValue),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['tableData', tableName] });
            toast.success('Row deleted successfully');
            setDeleteConfirmOpen(false);
            setRowToDelete(null);
        },
        onError: (error: any) => {
            toast.error(error.response?.data?.error || 'Failed to delete row');
        },
    });

    const handleEdit = (row: RowData) => {
        setEditingRow({ ...row });
    };

    const handleSaveEdit = () => {
        if (editingRow && primaryKey) {
            updateRowMutation.mutate({
                row: editingRow,
                pkValue: editingRow[primaryKey],
            });
        }
    };

    const handleCancelEdit = () => {
        setEditingRow(null);
    };

    const handleAddRow = () => {
        setIsAddingRow(true);
    };

    const handleSaveNewRow = () => {
        addRowMutation.mutate(newRow);
    };

    const handleCancelAddRow = () => {
        setIsAddingRow(false);
        setNewRow({});
    };

    const handleDeleteClick = (row: RowData) => {
        setRowToDelete(row);
        setDeleteConfirmOpen(true);
    };

    const handleConfirmDelete = () => {
        if (rowToDelete && primaryKey) {
            deleteRowMutation.mutate(rowToDelete[primaryKey]);
        }
    };

    const renderCellValue = (value: any) => {
        if (value === null) {
            return <Badge variant="secondary">NULL</Badge>;
        }
        if (typeof value === 'boolean') {
            return <Badge variant={value ? 'default' : 'outline'}>{value.toString()}</Badge>;
        }
        if (typeof value === 'object') {
            return JSON.stringify(value);
        }
        return String(value);
    };

    const renderEditableCell = (row: RowData, column: ColumnInfo, isNew: boolean = false) => {
        const value = row[column.name];
        const isEditing = primaryKey && editingRow?.[primaryKey] === row[primaryKey];
        const displayRow = isNew ? newRow : (isEditing ? editingRow : row);

        // Check if column is auto-generated
        const isAutoGenerated = column.is_primary_key ||
            column.default_value?.includes('nextval') ||
            ['created_at', 'updated_at', 'deleted_at'].includes(column.name.toLowerCase());

        // For new rows, don't show auto-generated columns
        if (isNew && isAutoGenerated) {
            return <span className="text-muted-foreground text-xs">Auto</span>;
        }

        // For existing rows, show auto-generated columns as read-only
        if (isAutoGenerated && !isNew) {
            return <span className="text-muted-foreground">{renderCellValue(value)}</span>;
        }

        // Safety check for displayRow
        if (!displayRow) {
            return <span className="text-muted-foreground">-</span>;
        }

        return (
            <Input
                type={column.type.includes('INT') ? 'number' : 'text'}
                value={displayRow[column.name] ?? ''}
                onChange={(e) => {
                    const newValue = e.target.value;
                    if (isNew) {
                        setNewRow(prev => ({ ...prev, [column.name]: newValue }));
                    } else {
                        setEditingRow(prev => prev ? { ...prev, [column.name]: newValue } : null);
                    }
                }}
                className="h-8"
                placeholder={column.nullable ? 'NULL' : ''}
            />
        );
    };

    if (!tableName) {
        return (
            <div className="flex items-center justify-center h-64 text-muted-foreground">
                <p>Select a table to view and edit data</p>
            </div>
        );
    }

    if (!columns || columns.length === 0) {
        return (
            <div className="flex items-center justify-center h-64">
                <p className="text-muted-foreground">Loading table schema...</p>
            </div>
        );
    }

    return (
        <div className="space-y-4">
            <div className="flex items-center justify-between">
                <div>
                    <h3 className="text-lg font-semibold">{tableName}</h3>
                    <p className="text-sm text-muted-foreground">
                        {totalRows} rows total
                    </p>
                </div>
                <Button onClick={handleAddRow} disabled={isAddingRow}>
                    <Plus className="h-4 w-4 mr-2" />
                    Add Row
                </Button>
            </div>

            <Card>
                <CardContent className="p-0">
                    <div className="overflow-x-auto">
                        <Table>
                            <TableHeader>
                                <TableRow>
                                    {columns.map((column) => (
                                        <TableHead key={column.name}>
                                            <div className="flex items-center gap-2">
                                                {column.name}
                                                {column.is_primary_key && (
                                                    <Badge variant="outline" className="text-xs">PK</Badge>
                                                )}
                                            </div>
                                        </TableHead>
                                    ))}
                                    <TableHead className="w-24">Actions</TableHead>
                                </TableRow>
                            </TableHeader>
                            <TableBody>
                                {isAddingRow && (
                                    <TableRow className="bg-muted/50">
                                        {columns.map((column) => (
                                            <TableCell key={column.name}>
                                                {renderEditableCell(newRow, column, true)}
                                            </TableCell>
                                        ))}
                                        <TableCell>
                                            <div className="flex items-center gap-1">
                                                <Button
                                                    size="sm"
                                                    variant="ghost"
                                                    onClick={handleSaveNewRow}
                                                    disabled={addRowMutation.isPending}
                                                >
                                                    <Save className="h-4 w-4" />
                                                </Button>
                                                <Button
                                                    size="sm"
                                                    variant="ghost"
                                                    onClick={handleCancelAddRow}
                                                >
                                                    <X className="h-4 w-4" />
                                                </Button>
                                            </div>
                                        </TableCell>
                                    </TableRow>
                                )}
                                {isLoading ? (
                                    <TableRow>
                                        <TableCell colSpan={columns.length + 1} className="text-center">
                                            Loading...
                                        </TableCell>
                                    </TableRow>
                                ) : rows.length === 0 ? (
                                    <TableRow>
                                        <TableCell colSpan={columns.length + 1} className="text-center text-muted-foreground">
                                            No data available
                                        </TableCell>
                                    </TableRow>
                                ) : (
                                    rows.map((row, idx) => {
                                        const isEditing = editingRow?.[primaryKey!] === row[primaryKey!];
                                        return (
                                            <TableRow key={idx} className={isEditing ? 'bg-muted/50' : ''}>
                                                {columns.map((column) => (
                                                    <TableCell key={column.name}>
                                                        {isEditing ? (
                                                            renderEditableCell(row, column)
                                                        ) : (
                                                            renderCellValue(row[column.name])
                                                        )}
                                                    </TableCell>
                                                ))}
                                                <TableCell>
                                                    {isEditing ? (
                                                        <div className="flex items-center gap-1">
                                                            <Button
                                                                size="sm"
                                                                variant="ghost"
                                                                onClick={handleSaveEdit}
                                                                disabled={updateRowMutation.isPending}
                                                            >
                                                                <Save className="h-4 w-4" />
                                                            </Button>
                                                            <Button
                                                                size="sm"
                                                                variant="ghost"
                                                                onClick={handleCancelEdit}
                                                            >
                                                                <X className="h-4 w-4" />
                                                            </Button>
                                                        </div>
                                                    ) : (
                                                        <div className="flex items-center gap-1">
                                                            <Button
                                                                size="sm"
                                                                variant="ghost"
                                                                onClick={() => handleEdit(row)}
                                                            >
                                                                <Pencil className="h-4 w-4" />
                                                            </Button>
                                                            <Button
                                                                size="sm"
                                                                variant="ghost"
                                                                onClick={() => handleDeleteClick(row)}
                                                            >
                                                                <Trash2 className="h-4 w-4 text-destructive" />
                                                            </Button>
                                                        </div>
                                                    )}
                                                </TableCell>
                                            </TableRow>
                                        );
                                    })
                                )}
                            </TableBody>
                        </Table>
                    </div>
                </CardContent>
            </Card>

            {/* Pagination */}
            {totalPages > 1 && (
                <div className="flex items-center justify-between">
                    <p className="text-sm text-muted-foreground">
                        Page {page} of {totalPages}
                    </p>
                    <div className="flex items-center gap-2">
                        <Button
                            variant="outline"
                            size="sm"
                            onClick={() => setPage(p => Math.max(1, p - 1))}
                            disabled={page === 1}
                        >
                            <ChevronLeft className="h-4 w-4" />
                            Previous
                        </Button>
                        <Button
                            variant="outline"
                            size="sm"
                            onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                            disabled={page === totalPages}
                        >
                            Next
                            <ChevronRight className="h-4 w-4" />
                        </Button>
                    </div>
                </div>
            )}

            {/* Delete Confirmation Dialog */}
            <Dialog open={deleteConfirmOpen} onOpenChange={setDeleteConfirmOpen}>
                <DialogContent>
                    <DialogHeader>
                        <DialogTitle>Confirm Delete</DialogTitle>
                        <DialogDescription>
                            Are you sure you want to delete this row? This action cannot be undone.
                        </DialogDescription>
                    </DialogHeader>
                    <DialogFooter>
                        <Button variant="outline" onClick={() => setDeleteConfirmOpen(false)}>
                            Cancel
                        </Button>
                        <Button
                            variant="destructive"
                            onClick={handleConfirmDelete}
                            disabled={deleteRowMutation.isPending}
                        >
                            Delete
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>
        </div>
    );
}

